*
*
*
	AST 32
*                              *
*                              *
*    DIRECTORY TITLE WRITER    *
*                              *
*      BY  VAL J. GOLDING      *
*                              *
*                              *
*      COPYRIGHT (C) 1981      *
*         VK UTILITIES         *
*                              *
	AST 32
*
*
MEMPTR = $0
IOB = $3
DOSFLG = $5
DRVNO = $6
TEMP = $7
TPLUS = $1B
CH = $24
CV = $25
A1L = $3C
A1H = $3D
A2L = $3E
A2H = $3F
A4L = $42
A4H = $43
INVFLG = $32
PROMPT = $33
*
*
BASIC = $3D0 BACK TO BASIC WITH DOS
RWTS = $3D9
GETIOB = $3E3
MEMCALC = $3D5
SLOT = $5F8
*
*
KBD = $C000
STROBE = $C010
PRBL2 = $F94A
VTAB = $FC22
HOME = $FC58
RDKEY = $FD0C
GETLN = $FD6A GET LINE OF CHRS
CROUT = $FD8E OUTPUT A C/R
PRBYTE = $FDDA PRINT HEX OF A
COUT = $FDED OUTPUT A CHAR
MOVE = $FE2C
SETINV = $FE80
SETNORM = $FE84
RESET = $FF59
GETNUM = $FFA7 GET A NBR
ZMODE = $FFC7
*
*
* DIRECTORY BUFFER OFFSETS
*
TLST = $4
SCCNT = $22
ENDMK = $21
TTLLNG = $23
*
*
*
	ORG $7000
*
*
*
PGMST LDA #$FF
	STA CHGSEC
	STA ACTIVE
	LDA #$0
	STA SC
*
*
*
* This clever bit of code looks at
* A6B3 which holds a zero in 3.2 DOS
* and non-zero in 3.3.  It then sets
* the variable DOSFLG accordingly.
*
	LDA MEMCALC CHECK MEMORY SIZE 
	ADC #$9 OFFSET TO HI BYTE OF  
	STA MEMPTR+1 LOCATION TO CHECK. 
	LDA #$B3 LO BYTE  
	STA MEMPTR
	LDY #$0
	LDA (MEMPTR),Y
	BNE NOT13 IF NON ZERO, IT'S 3.3 
	LDA #$D 
	STA DOSFLG
	BPL START
NOT13 LDA #$10 
	STA DOSFLG
*
*
START JSR GETIOB FIND DOS'S I/O BLOCK 
	STA DRVNO+1
	STY DRVNO 
	LDY #$10 
	LDA (DRVNO),Y GET LAST DRIVE NBR USED 
	STA DRVNO FILE IT, MAY NEED AGAIN 
*
	JSR TITLE
	JSR HOME
	JSR INTRO PRINT OPENING TITLES 
	JSR INIT SET UP OUR OWN I/O BLOCK 
*
*
*
Q1 JSR MSGOUT
	ASC '  SECTOR NBR ? '
	HEX 00
	JSR MSGIN
	STA IBSECT PUT IT IN THE IOB 
	BEQ Q1
	CMP DOSFLG CHECK WHICH DOS VERSION 
	BGE Q1
	JSR RDSEC
	JMP LINK
Q2 JSR MSGOUT
	ASC '  TITLE NBR ? (1-7) '
	HEX 00
	JSR MSGIN 
	STA DIRTTL
	BEQ Q2 ZERO IS A NO-NOO 
	CMP #$8 NEITHER IS 8 OR MORE 
	BGE Q2
	JSR CROUT
*
*
* This is where we check to see if the
* title number specified is an active file.
* If so, best ask user if he wants to
* replace it with his own title.
*
*
TFINDST JSR GETOFF
	CLC
	LDY DIRTTL
	LDA OFFSET 
	ADC #ENDMK-1
TFIND DEY
	CPY #$0
	BNE TFIND
	LDA OFFSET
	TAY
	LDA SECTBUF,Y
	STA ACTIVE
	BEQ Q3
*
*
*
	JSR TLMSG
	JMP HEXOUT+3 DISPLAY THE FOUND TITLE 
*
*
BACK LDA ACTIVE
	BPL REAL
	JSR MSGOUT
	ASC '] IS DELETED.  REPLACE IT ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BEQ Q3A
	JMP Q7
*
*
REAL JSR MSGOUT
	ASC ']   IS ACTIVE.  REPLACE IT ? (Y/N) ' 
	HEX 00
BACK1 JSR CHRIN
	CMP #"Y"
	BEQ Q3A
	JMP Q3 
*
*
*
Q3 JMP DELETE
	JSR CROUT
Q3A JSR DISMSG
	JSR MSGOUT ASK FOR DISPLAY MODE 
	ASC '(I/F/N) ? '
	HEX 00
	JSR CHRIN
	CMP #"I"
	BEQ IMODE
	CMP #"F"
	BEQ FMODE
	JMP CASE
IMODE LDA #$3F SET MODE FLAG 
	STA MODE FOR INVERSE 
	BPL Q4 
FMODE LDA #$7F OR FLASH 
	STA MODE
	BPL Q4 
*
CASE JSR CROUT
	JSR MSGOUT
	ASC '  UPPER CASE ONLY ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"N"
	BNE NMODE 
	LDA #$80 SET MODE FLAG FOR NORMAL U/CASE 
	STA MODE
	BMI Q4 
NMODE LDA #$FF OR LOWER 
	STA MODE
Q4 LDA ACTIVE
	BEQ Q5-3
	JSR CROUT
	JSR MSGOUT
	ASC '  CHANGE T/S PTR ? (Y/N) '
	HEX 00
	JSR CHRIN
	JSR CHGTS GO FIX IT 
Q5 NOP
	NOP
	JSR CHGFT
Q6 LDA ACTIVE
	BEQ Q6A
	JSR MSGOUT
	HEX 8D
	ASC '  SECTOR COUNT=0 ? (Y/N) '
	HEX 00
	JSR CHRIN
	JSR CHGSC FIX THIS ONE, TOO 
Q6A JMP ENTER
*
	HEX 8D8D00 
MODEMSG LDA MODE
	BMI MODEMSG1 IF NORMAL 
	JSR MSGOUT
	ASC '  HIT ESC TO ENTER A NORMAL CHARACTER.'
*
*
* This is the section that formats the 
* screen for title data entry and lets
* the user know in which display mode
* the data is being entered.  After
* reading the proper sector into a buffer,
* the new data is stored in the buffer
* and written back to the disk.
*
	HEX 8D00
MODEMSG1 JSR CROUT
	JSR BLANK
	JSR DISMSG
	LDA MODE
	CMP #$7F
	BEQ FTITLE
	CMP #$3F
	BEQ ITITLE
	JSR MSGOUT
	ASC 'NORMAL'
	HEX 8D00
	RTS
*
*
*
*
ITITLE STA INVFLG 
	JSR MSGOUT
	ASC 'INVERSE'
	HEX 8D00
	LDA #$FF
	STA INVFLG
	RTS
*
FTITLE STA INVFLG
	JSR MSGOUT
	ASC 'FLASH'
	HEX 8D00
	JSR SETNORM
	RTS
*
*
*
*
ENTER JSR HOME
	JSR MSGOUT
	HEX 8D8D
	ASC '  ENTER TITLE DATA BETWEEN BRACKETS'
	HEX 8D
	ASC '  TRAILING SPACES NEED NOT BE ENTERED.'
	HEX 8D00
	PLA
	LDA MODE
	CMP #$80 CHECK FOR LOWER CASE 
	BNE FORMAT
	JSR MSGOUT
	ASC '  Hit ESCape to capitalize'
	HEX 8D00
	JMP FORMAT
*
*
FORMAT JSR MSGOUT
	ASC '  ENTER CONTROL CHARACTERS ANY TIME'
	HEX 8D
	ASC '  ARROW KEYS <- -> MAY NOT BE USED.'
	HEX 8D00
	JSR MODEMSG
	JSR CURSEC
	JSR CURTTL
	JSR TSMSG
	JSR FTMSG
	JSR SCMSG
FORMAT1 JSR MSGOUT 
	HEX 8D8D8D8D
	ASC ' [______________________________]      '
	HEX 00
	LDA #$2 
	STA CH
	CLC
	LDA OFFSET
	ADC #TLST-1 
	TAX
	LDY #$0
*
*
* Here is where the dirty work is done;
* all conversions are made and the
* user's character is stored away.
*
CHRLOOP JSR RDKEY 
	CMP #$8D
	BEQ FINISH
	CMP #$9B
	BEQ CAP
	CMP #$A0 
	BLT CTLCHR 
	JSR MODECHK
	PLA
STORE STA SECTBUF,X
	JSR COUT
	INX 
	INY
	CPY #32 
	BEQ Q7
	JMP CHRLOOP
CTLCNV PLA
	SEC
	SBC #$80
	JMP STORE+3
CTLCHR STA SECTBUF,X
	PHA
	LDA MODE
	CMP #$3F
	BNE CTLCNV
	PLA
	SEC
	SBC #$40
	JMP STORE+3
FINISH LDA #$A0 
SPACE STA SECTBUF,X
	INX
	INY
	CPY #$20 
	BNE SPACE
	JMP Q7
*
CAP JSR RDKEY GET THE NEXT CHR AFTER AN 'ESC' 
	JMP STORE AND STORE IT IN THE BUFFER 
*
Q7 INC DIRTTL
	LDA DIRTTL
	CMP #$8 IF TITLE = 8, WE NEED 
	BEQ DS TO DISPLAY THE SECTOR AND FINISH
	PHA
	JSR MSGOUT 
	HEX 8D8D 
	ASC 'WRITE NEXT TITLE ? [NBR '
	HEX 00
	PLA
	JSR PRBYTE 
	JSR MSGOUT
	ASC '] (Y/N)' 
	HEX 00
	JSR CROUT
	JSR CHRIN
	CMP #"Y"
	BNE DS
	JSR GETOFF
	JMP TFINDST 
DS LDX #$FF
	JMP HEXOUT
*
*
*
* This section checks the MODE flag
* and then makes the proper conversions.
*
RGER JMP STORE-1
*
*
MODECHK PHA
	LDA MODE
	CMP #$FF
	BEQ RGER
	CMP #$80 
	BEQ LCASE
	CMP #$7F
	BNE INVTITLE
	PLA
	CMP #$C0 
	BLT NONALPH
INVCNV SEC
	SBC #$80
	JMP STORE ;+3 DOES ZERO WORK?
INVNTALF SEC 
	SBC #$80
	JMP STORE 
*
NONALPH SEC
	SBC #$40
	JMP STORE 
*
INVTITLE PLA
	CMP #$C0
	BLT INVNTALF
	SBC #$C0
	JMP STORE 
*
*
LCASE PLA
	CMP #$C0
	BGE ALPHA
	JMP STORE
*
*
ALPHA CLC
	ADC #$20
	JMP STORE
*
*
GETOFF LDY #$7
	STY TEMP
	LDA #$FF
	SEC
	SBC #TTLLNG
TLLOOP CPY DIRTTL
	BEQ SUBTR
	DEY
	BPL TLLOOP
*
SUBTR CPY TEMP
	BEQ SUBDONE
	SEC
	SBC #TTLLNG
	DEC TEMP
	JMP SUBTR
*
SUBDONE STA OFFSET 
	INC OFFSET
	RTS
*
*
*
TLMSG JSR HOME
	JSR MSGOUT 
	ASC 'TITLE ['
	HEX 00
	LDA OFFSET
	CLC
	ADC #$3 DON'T DISPLAY FIRST THREE BYTES 
	LDX #ENDMK-3 OFFSET X TO COME OUT EVEN 
	TAY
	RTS
*
*
*
* OUTPUT ROUTINES 
*
*
*
*
*
HEXOUT JSR HOME
	LDA SECTBUF,Y
	BEQ SKIPCHR DON'T DISPLAY ZEROS,  
	CMP #$80
	BLT THRU
	CMP #$A0
	BGE THRU
	SEC
	SBC #$40
THRU JSR COUT
	CPX #$FF TRICK TO CONFUSE THE X-REG
	BEQ INY
	DEX ;USED ONLY BY THE REPLACE? ROUTINE
	BEQ RTX
INY INY 
	CPY #$0
	BNE HEXOUT+3 
	JSR CROUT
	LDY #$0
*
*
* This section does the hex dump --
* prints two bytes, then a space.
*
NXTHEX LDA SECTBUF,Y
	JSR PRBYTE
	INY
	LDA SECTBUF,Y
	JSR PRBYTE
	LDA #$A0
	JSR COUT
	INY
	CPY #$0
	BNE NXTHEX
	JMP MORE
RTX JMP BACK
*
*
REPLACE DEX
	BNE INY 
	JMP BACK 
*
SKIPCHR LDA #$A0
	JMP THRU
*
*
*
CHGSC TAX 
	CLC
	LDA OFFSET
	ADC #SCCNT-1
	TAY
	TXA
	CMP #"Y"
	BEQ FIXIT
	LDA SECTBUF,Y
	STA SC
	RTS
FIXIT LDA #$0
	STA SC
	STA SECTBUF,Y
	RTS
*
*
*
*
CHGTS TAX
	LDA ACTIVE
	BNE CHGTS1
	LDX #"Y" FORCE A CHANGE
CHGTS1 LDA OFFSET
	TAY
	TXA
	CMP #"Y"
	BNE NOFIX
	LDA #$11
	STA SECTBUF,Y
	STA TL
	INY
	LDA #$01
	STA SECTBUF,Y
	STA SL
	JSR SAVEFT
	RTS
NOFIX LDA SECTBUF,Y
	STA TL
	INY
	LDA SECTBUF,Y
	STA SL
	JSR SAVEFT
	RTS
*
*
CHGFT JSR CROUT
	JSR MSGOUT
	ASC '  CHANGE FILE TYPE ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BNE NOTHNX
	JSR CROUT
	JSR MSGOUT
	ASC '  FILE TYPE OPTIONS: (A/B/I/R/S/T) '
	HEX 00
	JSR CHRIN
	STA FTASCII
	LDY #$0
FF CMP FTYPE,Y
	BEQ GOTIT
	INY
	CPY #$11 
	BLT FF
	BPL CHGFT
GOTIT STY FTHEX
	TYA
	LDY TPLUS
	STA SECTBUF,Y
	BPL RTS
*
NOTHNX LDA ACTIVE
	BNE YES
	LDA #$D4
	STA FTASCII
	BMI RTS
*
YES LDY TPLUS
	LDA SECTBUF,Y
	CMP #$80
	BLT NXTOP
	SEC
	SBC #$80
NXTOP STA FTHEX
	TAY
	LDA FTYPE,Y
	STA FTASCII
*
RTS RTS
*
*
*
*
SAVEFT INY 
	STY TPLUS
	LDA SECTBUF,Y
	STA FTHEX
	RTS
*
*
*
LINK JSR MSGOUT
	ASC '  CHANGE LINK ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BEQ CHLINK
	JSR CROUT
	JMP ANY 
CHLINK JSR CROUT
	JSR MSGOUT
	ASC '  TRACK ? '
	HEX 00
	JSR MSGIN
	CMP #$23
	BGE CHLINK
	LDY #$1
	STA SECTBUF,Y
	INY
CHLINK1 JSR CROUT
	JSR MSGOUT
	ASC '  SECTOR ? '
	HEX 00
	JSR MSGIN
	CMP DOSFLG
	BGE CHLINK1
	STA SECTBUF,Y
	LDX #$FF
	JMP HEXOUT
*
*
*
ANY JSR MSGOUT
	ASC '  CHANGE ANY BYTE ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BEQ ANYBYTE
	JSR CROUT
	JMP Q2
ANYBYTE JSR CROUT 
	JSR MSGOUT
	ASC '  BYTE TO CHANGE ? (0-FF) '
	HEX 00
	JSR MSGIN
	PHA 
	JSR CROUT
	JSR MSGOUT
	ASC '  DATA FOR BYTE ? '
	HEX 00
	JSR MSGIN
	TAX 
	PLA
	TAY
	TXA
	STA SECTBUF,Y
	LDX #$FF
	JMP HEXOUT
*
*
*
DELETE JSR CROUT
	JSR MSGOUT
	ASC '  DELETE THIS FILE ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BEQ KILLIT
	JSR CROUT
	LDA ACTIVE
	BNE DELETE1
	JMP Q3A
DELETE1 JMP Q7
KILLIT LDA OFFSET
	TAY
	LDA SECTBUF,Y
	PHA
	LDA #$FF
	STA SECTBUF,Y
	TYA
	ADC #ENDMK-2
	TAY
	PLA
	STA SECTBUF,Y
	LDX #$FF
	JMP Q7
*
*
*
*
*
*
*
BLANK LDX #$5 PRINT 5 SPACES 
	JSR PRBL2 
	RTS
*
*
*
TITLE JSR HOME
	LDA #>SECTBUF
	ADC #$1 
	STA A1H
	CLC
	ADC #$4
	STA A2H
	LDA #<SECTBUF
	STA A1L
	STA A2L
	LDA #$04
	STA A4H
	LDA #$0
	STA A4L
	JSR MOVE
	JSR CHRIN
	RTS
*
*
*
*
* INITIALIZE IOB, ETC. 
*
INIT LDY #<IOBLOCK+1 Here is where store the  
	LDA #>IOBLOCK+1 parameters required by 
	STY IOB our own I/O block. 
	STA IOB+1
	LDA #$11
	STA IBTRK
	LDA DOSFLG 
	STA IBSECT
	LDA #<DCT
	STA IBDCTP
	LDA #>DCT
	STA IBDCTP+1
	LDA #<SECTBUF
	STA IBBUFP 
	LDA #>SECTBUF
	STA IBBUFP+1
	LDA #$1
	STA IBCMD
	LDA #$0
	STA IBSTAT
	LDA SLOT
	STA IOBPSN
	STA IBSLOT
	LDA DRVNO 
	STA IOBPDN
	STA IBDRVN
	RTS
RDSEC LDY IOB GIVE RWTS IOB ADDRESS 
	LDA IOB+1 IN Y AND A REGS 
	JSR RWTS CALL RWTS FOR FIRST READ 
	JSR ERRMSG
	RTS
*
*
*
*
ERRMSG BCS ERRCK IF CARRY SET WE HAD AN ERROR 
	RTS
*
*
ERRCK LDA IBSTAT
	PHA
	LDA #$0
	STA IBSTAT
	STA CV
	JSR VTAB
	JSR BLANK 
	PLA
	CMP #$10
	BEQ WPERR
	JSR MSGOUT
	ASC '  FATAL ERROR * DISK I/O ' 
	HEX 87878D00
	JMP BASIC
*
*
WPERR JSR MSGOUT
	ASC '   WRITE PROTECT ERROR '
	HEX 87878D00
	PLA
	JMP MORE 
*
*
*
*
*
MORE JSR BLANK
	JSR SETINV
	JSR MSGOUT
	ASC ' WRITE SECTOR TO DISK (Y/N)? '
	HEX 00
	JSR SETNORM
	JSR CHRIN
	CMP #"Y"
	BEQ WRITE 
	JMP NEWSEC 
WRITE JSR HOME
	LDA #$2
	STA IBCMD
	LDY IOB
	LDA IOB+1
	JSR RWTS
	JSR ERRMSG
*LDA #1
	DEC IBCMD ;Restore read flag
*
*
*
NEWSEC JSR CROUT
	JSR MSGOUT
	ASC '  WRITE NEW SECTOR ? (Y/N) '
	HEX 00
	JSR CHRIN
	CMP #"Y"
	BNE NOPE
	JSR HOME
	JMP Q1
*
NOPE JSR HOME
	JMP BASIC
*
*
*
*
*
DISMSG JSR CROUT
	JSR MSGOUT
	ASC '  TITLE DISPLAY MODE: '
	HEX 00
	RTS
*
*
	JSR CROUT
*
*
CURSEC JSR CROUT
	JSR BLANK
	JSR MSGOUT
	ASC '  CURRENT SECTOR:     '
	HEX 00
	JSR SETINV
	LDA IBSECT
	JSR PRBYTE
	JSR SETNORM
	JSR CROUT
	RTS
*
*
CURTTL JSR BLANK
	JSR MSGOUT
	ASC '  CURRENT TITLE:      '
	HEX 00
	JSR SETINV
	LDA DIRTTL
	JSR PRBYTE
	JSR SETNORM
	JSR CROUT
	RTS
TSMSG JSR BLANK
	JSR MSGOUT
	ASC '  TRACK/SECTOR LIST:  '
	HEX 00
	JSR SETINV
	LDA #"$"
	JSR COUT
	LDA TL
	JSR PRBYTE
	LDA #","
	JSR COUT
	LDA #$A0
	JSR COUT
	LDA SL
	JSR PRBYTE
	JSR SETNORM
	JSR CROUT
	RTS
*
*
FTMSG JSR BLANK
	JSR MSGOUT
	ASC '  FILE TYPE:          '
	HEX 00
	JSR SETINV
	LDA FTASCII 
	NOP 
	JSR COUT
	JSR SETNORM
	JSR CROUT
	RTS
*
*
SCMSG JSR BLANK
	JSR MSGOUT
	ASC '  SECTOR COUNT:       '
	HEX 00
	JSR SETINV
	LDA SC
	JSR PRBYTE 
	JSR SETNORM
	JSR CROUT
	RTS
*
*
*
*
*
*
*
* MESSAGE OUTPUT BY ANDY HERTZFELD
*
*
MSGOUT PLA
	STA TEMP
	PLA
	STA TEMP+1
	LDY #0
LOOP INC TEMP 
	BNE SKIPADD
	INC TEMP+1
SKIPADD LDA (TEMP),Y GET CHR
	BEQ MSGRTS CHR=0, END OF STRING 
	ORA #$80
	JSR COUT OUTPUT CHR
	JMP LOOP
MSGRTS LDA TEMP+1 RESET RTS TO AFTER 
	PHA
	LDA TEMP
	PHA
	RTS
*
*
CHRIN BIT STROBE
KEY BIT KBD KEYPRESS?
	BPL KEY NO
	LDA KBD YES, SAVE IN ACC
	BIT STROBE
	JSR COUT
	RTS
*
*
*
MSGIN LDA #$A0
	STA PROMPT
	LDX #$0 This subroutine gets a string 
	JSR GETLN of ASCII characters representing
	JSR ZMODE hex, converts each two chrs to a 
	JSR GETNUM single byte, and returns 
	JSR CROUT it in A2L 
	LDA A2L
	RTS 
*
*
INTRO JSR MSGOUT
	HEX 8D8D
PGMEND ASC '  THIS PROGRAM ALLOWS YOU TO ENTER YOUR'
	HEX 8D
	ASC 'OWN DIRECTORY TITLES FROM THE KEYBOARD,' 
	HEX 8D
	ASC 'IN FLASH, INVERSE OR NORMAL, UPPER OR' 
	HEX 8D
	ASC 'LOWER CASE. FOLLOWING MAY BE SPECIFIED:'
	HEX 8D8D 
	ASC 'SECTOR NO:          [RANGE (1-C, 1-F)]'
	HEX 8D
	ASC 'CHANGE LINK:        [C/R=N]'
	HEX 8D
	ASC 'CHANGE ANY BYTE:    [C/R=N]'
	HEX 8D
	ASC 'TITLE NO.:          [RANGE (1-7)]'
	HEX 8D
	ASC 'DELETE A FILE:      [C/R=N]'
	HEX 8D
	ASC 'DISPLAY:            [C/R=NORMAL]'
	HEX 8D
	ASC 'U/L CASE:           [C/R=UPPER]'
	HEX 8D
	ASC 'CHANGE T/S POINTERS TO 11,1: [C/R=Y]'
	HEX 8D
	ASC 'CHANGE FILE TYPE:   [C/R=N]'
	HEX 8D
	ASC 'CHG SECTOR COUNT TO 0: [C/R=Y]'
	HEX 8D8D00
	JSR BLANK
	JSR BLANK
	JSR SETINV
	JSR MSGOUT
	ASC 'HIT ANY KEY TO CONTINUE'
	HEX 8D8D00 
	JSR SETNORM 
	JSR CHRIN
	JSR HOME
	RTS 
	BRK
*
*
*
*
* DATA FOR I/O BLOCK AND DCT 
*
* This is where we set up our very own 
* I/O Block, just like the one DOS has.
*
*
IOBLOCK NOP ;LABEL THE IOB 
IBTYPE HEX 01 ALWAYS 
IBSLOT DS 1 SLOT# * 16 
IBDRVN DS 1 DRV # THIS ACCESS
IBVOL HEX 00 VOL NBR EXPECTED 
IBTRK DS 1 TRK # THIS ACCESS
IBSECT DS 1 SEC # THIS ACCESS
IBDCTP DS 2 POINTERS TO DCT
IBBUFP DS 2 POINTERS TO SECTOR BUFFER
	HEX EAEA NOT USED 
IBCMD HEX 01 0=NULL 1=READ 2=WRITE 4=FORMAT
IBSTAT HEX 00 10=WRPRT 20=VLMM 40=DRER 80=RDER
IBSMOD DS 1 VOL # FOUND
IOBPSN DS 1 LAST SLOT ACCESSED
IOBPDN DS 1 LAST DRIVE ACCESSED
*
*
* DEVICE CHARACTERISTICS TABLE
*
DCT HEX 00 DEV CODE TYPE (00)
	HEX 01 PHASES PER TRK (01)
	HEX EFD8 TIMING COUNT 
*
* MISCELLANEOUS STORAGE AREA
*
*
OFFSET DS 1
CHGSEC DS 1
DIRTTL DS 1
SECNUM DS 1
MODE DS 1
TL DS 1
SL DS 1
FTP DS 1
SC DS 1
FTHEX DS 1 
*
*
FTASCII HEX D4 
FTYPE HEX D4C9C1FFC2
	HEX FFFFFFD3
	HEX FFFFFFFFFFFFFFD2
ACTIVE HEX FF
*
*
	DS $11 ;Set buffer to page boundary
NOP NOP ;Title screen BLOADs here + $100
SECTBUF = NOP ;Pgm hangs w/o mem move
* may store false data in page 4 scratch pads
	LST OFF
